<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Записи с тегом: postgresql on Блог Ивана Евтуховича</title>
    <link>https://evtuhovich.ru/tags/postgresql/</link>
    <description>Recent content in Записи с тегом: postgresql on Блог Ивана Евтуховича</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Fri, 28 Jun 2013 15:20:00 +0000</lastBuildDate><atom:link href="https://evtuhovich.ru/tags/postgresql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Статистика запросов и pg_stat_statements</title>
      <link>https://evtuhovich.ru/blog/2013/06/28/pg-stat-statements/</link>
      <pubDate>Fri, 28 Jun 2013 15:20:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2013/06/28/pg-stat-statements/</guid>
      <description>Иногда при эксплуатации проекта возникает вопрос, какие запросы в БД выполняются дольше всего или потребляют наибольшее количество времени или ресурсов.
До версии 9.2 неплохой ответ на этот вопрос можно было получить с помощью проекта pgBadger. Если прорваться через достаточно простую процедуру его настройки, описанную в документации, то в результате можно получить достаточно красивый отчет. К сожалению, этот подход имеет достаточно много слабых сторон. Во-первых, чтобы получить полную картину, необходимо писать логи всех запросов к БД, которые при значительной нагрузке отъедают огромное количество дискового пространства, а также производительность дисковой подсистемы.</description>
    </item>
    
    <item>
      <title>PostgreSQL 9.3 beta 1 на OSX</title>
      <link>https://evtuhovich.ru/blog/2013/05/15/postgresql-9-dot-3/</link>
      <pubDate>Wed, 15 May 2013 13:18:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2013/05/15/postgresql-9-dot-3/</guid>
      <description>&lt;p&gt;Два дня назад, 13 мая, &lt;a href=&#34;http://www.postgresql.org/about/news/1463/&#34;&gt;вышла beta 1 PostgreSQL 9.3&lt;/a&gt;. Во-первых, это хороший
знак, что уже пора обновляться на 9.2, либо выбирать 9.2 как основную БД. 9.3 планируется &lt;a href=&#34;http://www.postgresql.org/developer/roadmap/&#34;&gt;зарелизить в третьем квартале
2013 года&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Обо всех новых возможностях 9.3 можно почитать на &lt;a href=&#34;http://wiki.postgresql.org/wiki/What%27s_new_in_PostgreSQL_9.3&#34;&gt;официальной wiki&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но чтобы не только почитать, но и попробовать, я напишу здесь, как поставить 9.3 beta 1 на OSX.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>БД — большой кэш</title>
      <link>https://evtuhovich.ru/blog/2013/03/20/big-cache/</link>
      <pubDate>Wed, 20 Mar 2013 23:03:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2013/03/20/big-cache/</guid>
      <description>&lt;p&gt;В &lt;a href=&#34;blog/2013/02/24/partitioning/&#34;&gt;прошлый раз&lt;/a&gt; я обещал написать о том, что в проектах с более менее серьезной нагрузкой
БД либо помещается в память, либо не работает. Ситуация в современном мире меняется в связи с появлением SSD дисков, но
пока что они стоят достаточно дорого, по сравнению со старыми добрыми вращающимися дисками. Чтобы «потрогать» это
руками, проделаем несложный тест.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Партиционирование</title>
      <link>https://evtuhovich.ru/blog/2013/02/24/partitioning/</link>
      <pubDate>Sun, 24 Feb 2013 22:12:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2013/02/24/partitioning/</guid>
      <description>&lt;p&gt;Я долго считал партиционирование плохой практикой, а само слово не любил из-за кальки с английского, которую крайне
сложно выговорить с первого раза. И если слово «партиционирование» я так с первого раза и не выговариваю, то саму
практику пришлось признать как необходимое и неизбежное зло. Чтобы никто не подумал, что я делаю что-то плохое, я
использую для этого термин «инженерный компромисс», звучит умнее и не так обидно.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Блокировки в PostgreSQL</title>
      <link>https://evtuhovich.ru/blog/2013/01/27/locks/</link>
      <pubDate>Sun, 27 Jan 2013 22:35:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2013/01/27/locks/</guid>
      <description>&lt;p&gt;Чтобы рассказать о тонких моментах &lt;a href=&#34;https://evtuhovich.ru/blog/2013/01/09/fix-db-on-fly/&#34;&gt;pg_repack&lt;/a&gt;, мне понадобится немного углубиться в
тему блокировок в PostgreSQL. Конечно, лучше всего начать читать про них в &lt;a href=&#34;http://www.postgresql.org/docs/9.1/static/explicit-locking.html&#34;&gt;официальной документации&lt;/a&gt;. Для этой статьи достаточно понимать, что
эксклюзивная блокировка (ACCESS EXCLUSIVE LOCK) препятствует выполнению всех операций, включая &lt;code&gt;SELECT&lt;/code&gt;, и она нужна для операции
&lt;code&gt;ALTER TABLE&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ремонт БД на лету с помощью pg_repack</title>
      <link>https://evtuhovich.ru/blog/2013/01/09/fix-db-on-fly/</link>
      <pubDate>Wed, 09 Jan 2013 00:49:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2013/01/09/fix-db-on-fly/</guid>
      <description>&lt;p&gt;Окончились новогодние праздники, а это значит, что пора с новыми силами кинуться в бой с ИТ-сложностью, ИТ-хаосом
и другими ИТ бедами.&lt;/p&gt;
&lt;p&gt;Одной из бед всех версионных БД является разбухание таблиц. Все бы ничего, но если количество активно используемых
данных перестает влезать в оперативную память, то время обработки запросов к БД чрезвычайно сильно возрастает (об этом я
напишу в ближайшем будущем). И чтобы «впихнуть» размеры таблицы в нужный размер, иногда приходится делать некоторые нетрадиционные
трюки.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Index Only Scan в Postgresql 9.2</title>
      <link>https://evtuhovich.ru/blog/2012/10/10/index-only-scan/</link>
      <pubDate>Wed, 10 Oct 2012 13:09:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2012/10/10/index-only-scan/</guid>
      <description>&lt;p&gt;Вообще, сам не узнаю себя, уже ровно месяц прошел с выпуска &lt;a href=&#34;http://www.postgresql.org/docs/9.2/static/release-9-2.html&#34;&gt;Postgresql 9.2&lt;/a&gt;, даже вышло &lt;a href=&#34;http://www.postgresql.org/docs/9.2/static/release-9-2-1.html&#34;&gt;обновление 9.2.1&lt;/a&gt;, исправляющее некоторые баги, а я все еще ничего не написал об этом.&lt;/p&gt;
&lt;p&gt;Поэтому сегодня рассказ будет о Index Only Scan — самом заметном, по моему мнению, изменении в 9.2. Кстати, именно это
изменение стоит первым в &lt;a href=&#34;http://www.postgresql.org/docs/9.2/static/release-9-2.html&#34;&gt;Release Notes&lt;/a&gt;, а значит я не
одинок.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Barman и WAL-E</title>
      <link>https://evtuhovich.ru/blog/2012/07/27/backup/</link>
      <pubDate>Fri, 27 Jul 2012 15:54:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2012/07/27/backup/</guid>
      <description>&lt;p&gt;В postgresql есть замечательная возможность делать &lt;a href=&#34;http://www.postgresql.org/docs/9.1/interactive/continuous-archiving.html&#34;&gt;непрерывные бэкапы&lt;/a&gt;,
то есть бэкапы, по которым можно восстановиться на любой момент времени.&lt;/p&gt;
&lt;p&gt;Если вы делаете обычные бэкапы и запускаете в час ночи pg_dump, а в час дня ваш сервер БД умер, то вы потеряете данные за
12 часов и доверие ваших пользователей. Для многих web-сервисов такой сценарий неприемлем, и, чтобы минимизировать потери
данных, стоит использовать непрерывный бэкап.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Проблема с сортировкой русских слов в Postgres на OSX</title>
      <link>https://evtuhovich.ru/blog/2012/07/14/collate-osx-postgres/</link>
      <pubDate>Sat, 14 Jul 2012 13:17:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2012/07/14/collate-osx-postgres/</guid>
      <description>&lt;p&gt;Я давно мечтаю об Ubuntu, которая работает так же хорошо, как OSX. К несчастью, большинство пользовательских программ в
Ubuntu хуже, чем в OSX, а что касается серверной части - OSX очень сильно отстает от Ubuntu (Debian).&lt;/p&gt;
&lt;p&gt;К примеру, по-умолчанию, в Postgresql в OSX сломана сортировка русских слов. Решение я нашел
&lt;a href=&#34;http://chipiga.pp.ua/sql/kak-zastavit-postgresql-pravilno-sortirovat-utf8-kirillitsu-na-mac-os-x/&#34;&gt;здесь&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Поддержка JSON в PostgreSql 9.2</title>
      <link>https://evtuhovich.ru/blog/2012/03/14/postgresql-json/</link>
      <pubDate>Wed, 14 Mar 2012 23:52:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2012/03/14/postgresql-json/</guid>
      <description>В третьем квартале 2012 должна выйти версия PostgreSQL 9.2, в которой добавят много интересных возможностей. Среди них — базовая поддержка так полюбившегося всем web-разработчикам формата JSON. На данном этапе появится только возможность проверять JSON на валидность, но судя по списку рассылки, к версии 9.3 будет добавлена возможность строить индексы на JSON объектах подобно тому, как это можно сделать на hstore. Конечно, JSON объекты гораздо сложнее hstore, и как именно и в каком объеме будет реализована поддержка индексов в JSON — пока не ясно.</description>
    </item>
    
    <item>
      <title>Hstore — key-value расширение для postgresql</title>
      <link>https://evtuhovich.ru/blog/2012/01/23/hstore/</link>
      <pubDate>Mon, 23 Jan 2012 23:05:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2012/01/23/hstore/</guid>
      <description>&lt;p&gt;Наверное, не все знают, что для postgresql существует большое количество расширений, которые называются
&lt;a href=&#34;http://www.postgresql.org/docs/9.1/static/contrib.html&#34;&gt;contrib модулями&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Рассмотрим один из таких модулей - &lt;a href=&#34;http://www.postgresql.org/docs/9.1/static/hstore.html&#34;&gt;hstore&lt;/a&gt;. Этот модуль
нужен для того, чтобы в одном поле в БД хранить много значений key/value, фактически, просто какой-то хеш. При этом и
ключи и значения могут быть только строками. О том, чем это лучше, нежели просто хранить в текстовом поле сериализованный хеш,
я расскажу чуть-чуть попозже. Понадобится это может в том случае, если у вас есть модели с произвольным набором полей.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Библия PostgreSQL</title>
      <link>https://evtuhovich.ru/blog/2011/12/27/bible/</link>
      <pubDate>Tue, 27 Dec 2011 17:11:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2011/12/27/bible/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://evtuhovich.ru/images/pg-book.jpg&#34; alt=&#34;Библия&#34;&gt;&lt;/p&gt;
&lt;p&gt;Если вы работаете с postgresql и сталкиваетесь с затруднительными ситуациями, ответы на которые даже не ясно, как
гуглить, то, скорее всего, вам не хватает каких-то фундаментальных знаний этой БД.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PgQ и Londiste</title>
      <link>https://evtuhovich.ru/blog/2009/06/05/pgq-londiste-plugin/</link>
      <pubDate>Fri, 05 Jun 2009 12:34:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2009/06/05/pgq-londiste-plugin/</guid>
      <description>Хотя я так и не написал толком, как пользоваться PgQ и Londiste, но уже написал плагин, который облегчает его использование вместе с рельсами.
http://github.com/evtuhovich/pgq/tree/master
В README всё написано на плохом английском (с хорошим английским у меня плохо).
Совсем скоро я добавлю туда возможность прогонять миграции на master и slave базах данных одновременно. Тогда при очередной выкатке необходимо будет сделать только rake londiste:update в самом конце, после того, как все миграции прогонятся.</description>
    </item>
    
    <item>
      <title>Перенос таблицы в другую базу данных postgres без простоя приложения</title>
      <link>https://evtuhovich.ru/blog/2009/05/22/live-table-migration/</link>
      <pubDate>Fri, 22 May 2009 23:45:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2009/05/22/live-table-migration/</guid>
      <description>В продолжении темы о нескольких базах данных в одном rails-приложении расскажу о том, как изящно перенести одну большую таблицу в другую БД postgresql.
Пусть у нас есть таблица messages с большим количеством данных (10 миллионов записей), которые мы решили перенести на другой сервер. Мы сделали, как написано в статье, указанной выше, а также создали в новой БД таблицу messages с такой же структурой.
Теперь с помощью londiste настраиваем репликацию из первой БД во вторую для таблицы messages (об этом я напишу подробнее попозже, пока же можно прочитать об этом у Андрея Стихеева в рассылке ror2ru).</description>
    </item>
    
    <item>
      <title>Конкурентное пересоздание индексов в postgresql</title>
      <link>https://evtuhovich.ru/blog/2009/04/08/concurent-index/</link>
      <pubDate>Wed, 08 Apr 2009 11:11:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2009/04/08/concurent-index/</guid>
      <description>На таблице postgresql с большим количеством данных невозможно быстро создать либо пересоздать индекс. При создании индекса таблица блокируется для операций INSERT, UPDATE и DELETE. В таких случаях может помочь конкурентное создание индекса. Иногда на postgresql стоит пересоздавать индексы, чтобы уменьшить их фрагментацию (и увеличить скорость). Создание конкурентного индекса будет частным случаем его пересоздания.
Пусть имеется таблица orders с 1 миллионом записей (приблизительно) в которой хранятся заказы. И в этой таблице есть поля country_id, region_id, city_id, на которых создан индекс.</description>
    </item>
    
    <item>
      <title>Использование очередей в высоконагруженных проектах</title>
      <link>https://evtuhovich.ru/blog/2009/04/04/queue/</link>
      <pubDate>Sat, 04 Apr 2009 23:45:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2009/04/04/queue/</guid>
      <description>При большом количестве запросов к приложению (в широком смысле этого слова) иногда целесообразно ``размазать&amp;rsquo;&amp;rsquo; пиковую нагрузку во времени. Для этого удобно использовать очереди. То есть, если какое-то запрос наверняка должен быть выполнен, но не имеет значение произойдет это прямо сейчас или чуть попозже, можно создать событие в очереди. И когда до этого события дойдет очередь —&amp;ndash; оно будет выполнено. Таким образом можно развести сложные запросы во времени.
Очереди подходят для таких задач, как, например, рассылка большого количества сообщений и обновление различных счетчиков в БД (если их актуальность не очень критична).</description>
    </item>
    
    <item>
      <title>PosgtreSql, миграции и огромные таблицы</title>
      <link>https://evtuhovich.ru/blog/2009/03/20/big-tables/</link>
      <pubDate>Fri, 20 Mar 2009 12:34:00 +0000</pubDate>
      
      <guid>https://evtuhovich.ru/blog/2009/03/20/big-tables/</guid>
      <description>Миграции в rails — это очень правильный инструмент. Правда, иногда случаются казусы, потому что конкретная БД перестает быть «сферическим конем в вакууме», как только количество данных и нагрузка на нее становится существенной.
Пусть у нас есть таблица posts, в которой 10 миллионов записей. И мы решили добавить в нее поле is_searchable.
 $ script/generate migration add_is_searchable_to_posts  class AddIsSearchableToPosts &amp;lt; ActiveRecord::Migration  def self.up  add_column :posts, :is_searchable, :boolean, :default =&amp;gt; true, :null =&amp;gt; false  end   def self.</description>
    </item>
    
  </channel>
</rss>
